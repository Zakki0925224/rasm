use std::{
    env,
    fs::File,
    io::{Read, Write},
    path::Path,
    process::Command,
};

use byteorder::{ByteOrder, LittleEndian};

use crate::{elf::Elf64Header, parse::parse};

mod elf;
mod parse;

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() != 2 {
        panic!("Invalid arguments");
    }

    let filepath = Path::new(&args[1]);

    let mut file = File::open(filepath).expect("File not found");
    let mut text = String::new();
    file.read_to_string(&mut text)
        .expect("Failed to read strings");

    let lines: Vec<&str> = text.split("\n").collect();

    for (i, line) in lines.iter().enumerate() {
        // empty line
        if line.len() == 0 {
            println!(
                "{} line {}: \"{}\" => Skipping empty line...",
                filepath.to_str().unwrap(),
                i + 1,
                line
            );
            continue;
        }

        // comment line
        if line.chars().nth(0).unwrap() == ';' {
            println!(
                "{} line {}: \"{}\" => Skipping comment line...",
                filepath.to_str().unwrap(),
                i + 1,
                line
            );
            continue;
        }

        match parse(line) {
            Ok(ins) => {
                println!(
                    "{} line {}: \"{}\" => {:?}",
                    filepath.to_str().unwrap(),
                    i + 1,
                    line,
                    ins
                );
            }
            Err(err) => {
                println!(
                    "{} line {}: \"{}\" => {:?}",
                    filepath.to_str().unwrap(),
                    i + 1,
                    line,
                    err
                );
            }
        };
    }

    panic!("breakpoint");

    let return_code: u8 = text.replace("\n", "").parse().unwrap();

    let obj1 = [
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0,
        0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x1,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    ];

    let mut section_size = [0x0; 8];

    let obj2 = [
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x90, 0x1, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x0,
        0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0xc0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x2, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x16, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    ];

    let text = [
        0xb8,
        0x3c,
        0x0,
        0x0,
        0x0,
        0xbf,
        return_code,
        0x0,
        0x0,
        0x0,
        0xf,
        0x5,
    ];

    LittleEndian::write_u64(&mut section_size, text.len() as u64);

    let obj3 = [
        0x0, 0x0, 0x0, 0x0, 0x0, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x0, 0x2e, 0x73, 0x68, 0x73, 0x74,
        0x72, 0x74, 0x61, 0x62, 0x0, 0x2e, 0x73, 0x79, 0x6d, 0x74, 0x61, 0x62, 0x0, 0x2e, 0x73,
        0x74, 0x72, 0x74, 0x61, 0x62, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x4, 0x0, 0xf1, 0xff,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x3, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x74, 0x65, 0x73, 0x74, 0x2f, 0x6d,
        0x69, 0x6e, 0x2e, 0x6e, 0x61, 0x73, 0x6d, 0x0, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    ];

    let export_filepath = filepath.with_extension("o");
    let mut file = File::create(export_filepath.clone()).expect("Failed to create file");

    let bytes = [
        Elf64Header::template().as_u8_slice(),
        &obj1,
        &section_size,
        &obj2,
        &text,
        &obj3,
    ]
    .concat();
    file.write_all(&bytes).expect("Failed to write file");

    // link
    let out = Command::new("ld")
        .args([
            "-m",
            "elf_x86_64",
            "-o",
            export_filepath
                .clone()
                .with_extension("elf")
                .to_str()
                .unwrap(),
            export_filepath.to_str().unwrap(),
        ])
        .output()
        .expect("Failed to execute ld");
    println!("{:?}", out);
}
