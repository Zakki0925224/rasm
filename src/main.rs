use std::{
    env,
    fs::File,
    io::{Read, Write},
    path::Path,
    process::Command,
};

use byteorder::{ByteOrder, LittleEndian};

use crate::{elf::Elf64Header, parse::parse};

mod elf;
mod parse;

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() != 2 {
        panic!("Invalid arguments");
    }

    let filepath = Path::new(&args[1]);

    let mut file = File::open(filepath).expect("File not found");
    let mut text = String::new();
    file.read_to_string(&mut text)
        .expect("Failed to read strings");

    let lines: Vec<&str> = text.split("\n").collect();
    let mut text = Vec::new();

    for (i, line) in lines.iter().enumerate() {
        // empty line
        if line.len() == 0 {
            println!(
                "{} line {}: \"{}\" => Skipping empty line...",
                filepath.to_str().unwrap(),
                i + 1,
                line
            );
            continue;
        }

        // comment line
        if line.chars().nth(0).unwrap() == ';' {
            println!(
                "{} line {}: \"{}\" => Skipping comment line...",
                filepath.to_str().unwrap(),
                i + 1,
                line
            );
            continue;
        }

        match parse(line) {
            Ok(ins) => {
                println!(
                    "{} line {}: \"{}\" => {:?}",
                    filepath.to_str().unwrap(),
                    i + 1,
                    line,
                    ins
                );

                if let Some(opcode) = ins.opcode {
                    text.extend(opcode.get_opcode());
                }
            }
            Err(err) => {
                println!(
                    "{} line {}: \"{}\" => {:?}",
                    filepath.to_str().unwrap(),
                    i + 1,
                    line,
                    err
                );
            }
        };
    }

    let obj1 = [
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0,
        0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x1,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    ];

    let mut section_size = [0x0; 8];
    LittleEndian::write_u64(&mut section_size, text.len() as u64);

    let obj2 = [
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x90, 0x1, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x0,
        0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0xc0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x2, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x16, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    ];

    let symbol_table = [
        0x0, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x0, 0x2e, 0x73, 0x68, 0x73, 0x74, 0x72, 0x74, 0x61,
        0x62, 0x0, 0x2e, 0x73, 0x79, 0x6d, 0x74, 0x61, 0x62, 0x0, 0x2e, 0x73, 0x74, 0x72, 0x74,
        0x61, 0x62, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    ];

    let obj3 = [
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x4, 0x0, 0xf1, 0xff, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0,
        0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0xf, 0x0, 0x0, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    ];

    // string table is 16byte align
    // TODO allows 13 chars only ex: "test/nop.nasm"
    let mut string_table = vec![0x0];
    string_table.extend(format!("{}\0", filepath.to_str().unwrap().replace("./", "")).as_bytes());
    string_table.extend("_start\0".as_bytes());

    if string_table.len() % 16 != 0 {
        for _ in 0..16 - (string_table.len() % 16) {
            string_table.push(0x0);
        }
    }

    // .text is 16byte align
    if text.len() % 16 != 0 {
        for _ in 0..16 - (text.len() % 16) {
            text.push(0x0);
        }
    }

    let export_filepath = filepath.with_extension("o");
    let mut file = File::create(export_filepath.clone()).expect("Failed to create file");

    let bytes = [
        Elf64Header::template().as_u8_slice(),
        &obj1,
        &section_size,
        &obj2,
        &text,
        &symbol_table,
        &obj3,
        &string_table,
    ]
    .concat();
    //println!("{:02x?}", bytes);
    file.write_all(&bytes).expect("Failed to write file");

    // link
    let out = Command::new("ld")
        .args([
            "-m",
            "elf_x86_64",
            "-o",
            export_filepath
                .clone()
                .with_extension("elf")
                .to_str()
                .unwrap(),
            export_filepath.to_str().unwrap(),
        ])
        .output()
        .expect("Failed to execute ld");
    println!("{:?}", out);
}
